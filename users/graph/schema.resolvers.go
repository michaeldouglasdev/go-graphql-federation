package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"
	"go-graphql-apollo-federation/users/graph/model"
	"go-graphql-apollo-federation/users/internal/db"
	"go-graphql-apollo-federation/users/internal/middleware"
	"os"
	"time"

	jwt "github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

// Users is the resolver for the users field.
func (r *mutationResolver) Users(ctx context.Context) (*model.UsersMutations, error) {
	return &model.UsersMutations{}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) (*model.UsersQueries, error) {
	return &model.UsersQueries{}, nil
}

// Results is the resolver for the results field.
func (r *usersAllResultsResolver) Results(ctx context.Context, obj *model.UsersAllResults) ([]*model.User, error) {
	users, err := r.UserDB.ListUsers(ctx)
	var usersModel []*model.User

	for _, user := range users {
		usersModel = append(usersModel, &model.User{
			ID:       user.ID,
			Name:     user.Name,
			Username: user.Username,
			Type:     model.UserType(user.Type),
		})
	}
	return usersModel, err
}

// Create is the resolver for the create field.
func (r *usersMutationsResolver) Create(ctx context.Context, obj *model.UsersMutations, data model.CreateUserInput) (model.UsersCreateResponse, error) {
	id := uuid.NewString()
	hash, err := bcrypt.GenerateFromPassword([]byte(data.Password), bcrypt.DefaultCost)
	if err != nil {
		return &model.Error{
			Message: "An error occurred while registering",
		}, nil
	}

	hashedPassword := string(hash)
	println("Password Create", hashedPassword)
	_, err = r.UserDB.CreateUser(ctx, db.CreateUserParams{
		ID:       id,
		Username: data.Username,
		Password: hashedPassword,
		Name:     data.Name,
		Type:     "BASIC",
	})

	if err != nil {
		return &model.Error{
			Message: "An error occurred while registering",
		}, nil
	}

	user, err := r.UserDB.GetUser(ctx, id)

	if err != nil {
		return &model.Error{
			Message: "An error occurred while registering: %s",
		}, nil
	}

	return &model.User{
		ID:       user.ID,
		Name:     user.Name,
		Username: user.Username,
		Type:     model.UserType(user.Type),
	}, nil
}

// Login is the resolver for the login field.
func (r *usersMutationsResolver) Login(ctx context.Context, obj *model.UsersMutations, data model.LoginUserInput) (model.LoginUserResponse, error) {
	user, err := r.UserDB.Login(ctx, data.Username)

	if err != nil {
		return &model.LoginUserInvalidUsernameOrPasswordError{
			Message: "Invalid username or password",
		}, nil
	}

	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(data.Password))
	if err != nil {
		println("err", err.Error())
		return &model.LoginUserInvalidUsernameOrPasswordError{
			Message: "Invalid username or password",
		}, nil
	}

	userModel := &model.User{
		ID:       user.ID,
		Name:     user.Name,
		Username: user.Username,
		Type:     model.UserType(user.Type),
	}

	token := jwt.New(jwt.SigningMethodHS256)
	exp := time.Now().Add(time.Hour * 24)

	claims := &middleware.UserClaims{
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(exp),
			Subject:   "MDD",
		},
		User: *userModel,
	}

	token.Claims = claims

	/*tokenJwt := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user": userModel,
		"exp":  time.Now().Add(1 * time.Hour).Unix(),
	})*/

	jwtSecret := os.Getenv("JWT_SECRET")
	key := []byte(jwtSecret)
	tokenJwtEncoded, err := token.SignedString(key)

	return &model.Login{
		ExpiresIn:   3600,
		User:        userModel,
		AccessToken: tokenJwtEncoded,
	}, nil
}

// All is the resolver for the all field.
func (r *usersQueriesResolver) All(ctx context.Context, obj *model.UsersQueries) (model.UsersAllResponse, error) {
	return &model.UsersAllResults{}, nil
}

// Get is the resolver for the get field.
func (r *usersQueriesResolver) Get(ctx context.Context, obj *model.UsersQueries, data model.GetUserInput) (model.GetUserResponse, error) {
	user, err := r.UserDB.GetUser(ctx, data.Value)

	if err != nil {
		return &model.UserNotFoundError{
			Message: err.Error(),
		}, nil
	}

	return &model.User{
		ID:   user.ID,
		Name: user.Name,
	}, nil
}

// Me is the resolver for the me field.
func (r *usersQueriesResolver) Me(ctx context.Context, obj *model.UsersQueries) (model.MeUserResponse, error) {
	userCtx := ctx.Value("user")

	user := userCtx.(*model.User)

	return &model.User{
		ID:       user.ID,
		Name:     user.Name,
		Username: user.Username,
		Type:     user.Type,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// UsersAllResults returns UsersAllResultsResolver implementation.
func (r *Resolver) UsersAllResults() UsersAllResultsResolver { return &usersAllResultsResolver{r} }

// UsersMutations returns UsersMutationsResolver implementation.
func (r *Resolver) UsersMutations() UsersMutationsResolver { return &usersMutationsResolver{r} }

// UsersQueries returns UsersQueriesResolver implementation.
func (r *Resolver) UsersQueries() UsersQueriesResolver { return &usersQueriesResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type usersAllResultsResolver struct{ *Resolver }
type usersMutationsResolver struct{ *Resolver }
type usersQueriesResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
type usersAllResultResolver struct{ *Resolver }

func (r *userResolver) Type(ctx context.Context, obj *model.User) (*model.UserType, error) {
	panic(fmt.Errorf("not implemented: Type - type"))
}

type userResolver struct{ *Resolver }
