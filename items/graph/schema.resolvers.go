package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"database/sql"
	"fmt"
	"go-graphql-apollo-federation/items/graph/model"
	"go-graphql-apollo-federation/items/internal/db"

	"github.com/google/uuid"
)

// Create is the resolver for the create field.
func (r *itemsMutationsResolver) Create(ctx context.Context, obj *model.ItemsMutations, data model.ItemsCreateInput) (model.ItemsCreateResponse, error) {
	id := uuid.NewString()
	if data.Food != nil {
		_, err := r.ItemDB.CreateItem(ctx, db.CreateItemParams{
			ID:    id,
			Name:  data.Food.Name,
			Price: data.Food.Price,
			Image: data.Food.Image,
			Weight: sql.NullString{
				String: data.Food.Weight,
				Valid:  true,
			},
			ExpirationTime: sql.NullString{
				String: data.Food.ExpirationTime,
				Valid:  true,
			},
			Type: db.ItemsTypeFOOD,
		})

		if err != nil {
			println("err1", err.Error())
			return model.Error{
				Message: "An error occurred while creating item",
			}, nil
		}

		item, err := r.ItemDB.GetItem(ctx, id)

		return &model.ItemFood{
			ID:   item.ID,
			Name: item.Name,
			Price: &model.ItemPrice{
				Value: item.Price,
			},
			ExpirationTime: &item.ExpirationTime.String,
			Weight:         item.Weight.String,
			Image:          item.Image,
		}, nil
	}
	if data.Toy != nil {
		_, err := r.ItemDB.CreateItem(ctx, db.CreateItemParams{
			ID:    id,
			Name:  data.Toy.Name,
			Price: data.Toy.Price,
			Image: data.Toy.Image,
			Material: sql.NullString{
				String: string(data.Toy.Material),
				Valid:  true,
			},
			SuitableFor: db.NullItemsSuitableFor{
				ItemsSuitableFor: db.ItemsSuitableFor(data.Toy.SuitableFor),
				Valid:            true,
			},
			Type: db.ItemsTypeTOY,
		})

		if err != nil {
			return &model.Error{
				Message: "An error occurred while creating item",
			}, nil
		}

		item, err := r.ItemDB.GetItem(ctx, id)
		if err != nil {
			return &model.Error{
				Message: "An error occurred while creating item",
			}, nil
		}

		return &model.ItemToy{
			ID:   item.ID,
			Name: item.Name,
			Price: &model.ItemPrice{
				Value: item.Price,
			},
			Image:    item.Image,
			Material: model.ToyMaterial(item.Material.String),
		}, nil
	}
	println("aqui")
	return model.Error{
		Message: "An error occurred while creating item",
	}, nil
}

// Foods is the resolver for the foods field.
func (r *itemsMutationsResolver) Foods(ctx context.Context, obj *model.ItemsMutations) (*model.ItemsFoodsMutationsResponse, error) {
	return &model.ItemsFoodsMutationsResponse{}, nil
}

// Toys is the resolver for the toys field.
func (r *itemsMutationsResolver) Toys(ctx context.Context, obj *model.ItemsMutations) (*model.ItemsFoodsMutationsResponse, error) {
	panic(fmt.Errorf("not implemented: Toys - toys"))
}

// List is the resolver for the list field.
func (r *itemsQueriesResolver) List(ctx context.Context, obj *model.ItemsQueries, data *model.ItemsListInput) (model.ItemsListResponse, error) {
	items, err := r.ItemDB.ListItems(ctx)
	if err != nil {
		return &model.Error{
			Message: "An error occurred while listing items",
		}, nil
	}

	var itemsModel []model.Item
	for _, item := range items {
		if item.Type == db.ItemsTypeFOOD {
			itemsModel = append(itemsModel, &model.ItemFood{
				ID:   item.ID,
				Name: item.Name,
				Price: &model.ItemPrice{
					Value: item.Price,
				},
				Weight:         item.Weight.String,
				ExpirationTime: &item.ExpirationTime.String,
				Image:          item.Image,
			})
		}
		if item.Type == db.ItemsTypeTOY {
			itemsModel = append(itemsModel, &model.ItemToy{
				ID:   item.ID,
				Name: item.Name,
				Price: &model.ItemPrice{
					Value: item.Price,
				},
				Image:       item.Image,
				Material:    model.ToyMaterial(item.Material.String),
				SuitableFor: model.ToySuitableFor(item.SuitableFor.ItemsSuitableFor),
			})
		}
	}
	return &model.ItemsListResults{
		Results: itemsModel,
	}, nil
}

// Get is the resolver for the get field.
func (r *itemsQueriesResolver) Get(ctx context.Context, obj *model.ItemsQueries, data model.ItemsGetInput) (model.ItemsGetResponse, error) {
	item, err := r.ItemDB.GetItem(ctx, data.ID)

	if err != nil {
		return &model.Error{
			Message: "An error occurred while getting item",
		}, nil
	}
	if item.Type == db.ItemsTypeFOOD {
		return &model.ItemFood{
			ID:   item.ID,
			Name: item.Name,
			Price: &model.ItemPrice{
				Value: item.Price,
			},
			Weight:         item.Weight.String,
			ExpirationTime: &item.ExpirationTime.String,
			Image:          item.Image,
		}, nil
	}
	if item.Type == db.ItemsTypeTOY {
		return &model.ItemToy{
			ID:   item.ID,
			Name: item.Name,
			Price: &model.ItemPrice{
				Value: item.Price,
			},
			Image:       item.Image,
			Material:    model.ToyMaterial(item.Material.String),
			SuitableFor: model.ToySuitableFor(item.SuitableFor.ItemsSuitableFor),
		}, nil
	}

	return nil, nil
}

// Items is the resolver for the items field.
func (r *mutationResolver) Items(ctx context.Context) (*model.ItemsMutations, error) {
	return &model.ItemsMutations{}, nil
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context) (*model.ItemsQueries, error) {
	return &model.ItemsQueries{}, nil
}

// ItemsMutations returns ItemsMutationsResolver implementation.
func (r *Resolver) ItemsMutations() ItemsMutationsResolver { return &itemsMutationsResolver{r} }

// ItemsQueries returns ItemsQueriesResolver implementation.
func (r *Resolver) ItemsQueries() ItemsQueriesResolver { return &itemsQueriesResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type itemsMutationsResolver struct{ *Resolver }
type itemsQueriesResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
